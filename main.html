import React, { useState, useMemo } from "react";

// GuitarChordExplorer.jsx
// Single-file React component that provides:
// - Key selector (major keys, sharps/flats)
// - Input box for chord component notes (e.g. C E G or C,E,G or Cmaj7 -> but prefer notes)
// - Identification engine: tries roots and matches interval patterns against many chord types
// - Simple guitar fretboard visualizer: maps chord pitch-classes to possible frets (0-12)
//
// Notes:
// - This is a best-effort comprehensive chord identifier. Very exotic or ambiguous voicings
//   may have multiple valid interpretations; the app lists matches sorted by score.
// - Fretboard finder is heuristic: finds a plausible fret per string within a low fret span.

const NOTE_NAMES_SHARP = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
const NOTE_NAMES_FLAT = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"];

const MAJOR_KEYS = [
  "C", "G", "D", "A", "E", "B", "F#", "C#", "F", "Bb", "Eb", "Ab", "Db", "Gb",
];

// Guitar standard tuning (E A D G B E) string pitch classes from low (6th) to high (1st)
const GUITAR_STRINGS = [4, 9, 2, 7, 11, 4]; // E2 A2 D3 G3 B3 E4 in pitch classes

// Chord pattern dictionary: intervals in semitones from root, sorted
// We include many common/less-common chords. Each entry: {name, intervals, aliases}
const CHORD_PATTERNS = [
  { name: "maj", intervals: [0, 4, 7], aliases: [""] },
  { name: "min", intervals: [0, 3, 7], aliases: ["m", "-"] },
  { name: "dim", intervals: [0, 3, 6], aliases: ["dim", "o"] },
  { name: "aug", intervals: [0, 4, 8], aliases: ["+", "aug"] },
  { name: "sus2", intervals: [0, 2, 7], aliases: ["sus2"] },
  { name: "sus4", intervals: [0, 5, 7], aliases: ["sus4", "sus"] },
  { name: "6", intervals: [0, 4, 7, 9], aliases: ["6"] },
  { name: "m6", intervals: [0, 3, 7, 9], aliases: ["m6"] },
  { name: "7", intervals: [0, 4, 7, 10], aliases: ["dom7", "7"] },
  { name: "maj7", intervals: [0, 4, 7, 11], aliases: ["M7", "maj7"] },
  { name: "m7", intervals: [0, 3, 7, 10], aliases: ["m7"] },
  { name: "mMaj7", intervals: [0, 3, 7, 11], aliases: ["mMaj7"] },
  { name: "dim7", intervals: [0, 3, 6, 9], aliases: ["dim7"] },
  { name: "m7b5", intervals: [0, 3, 6, 10], aliases: ["m7b5", "Ã¸"] },
  { name: "add9", intervals: [0, 4, 7, 14], aliases: ["add9"] },
  { name: "9", intervals: [0, 4, 7, 10, 14], aliases: ["9"] },
  { name: "11", intervals: [0, 4, 7, 10, 14, 17], aliases: ["11"] },
  { name: "13", intervals: [0, 4, 7, 10, 14, 17, 21], aliases: ["13"] },
  { name: "sus2add6", intervals: [0, 2, 7, 9], aliases: ["sus2add6"] },
  { name: "sus4add9", intervals: [0, 5, 7, 14], aliases: ["sus4add9"] },
  { name: "5", intervals: [0, 7], aliases: ["5", "power"] },
  { name: "add11", intervals: [0, 4, 7, 17], aliases: ["add11"] },
  { name: "add2", intervals: [0, 4, 7, 2], aliases: ["add2"] },
  { name: "maj9", intervals: [0, 4, 7, 11, 14], aliases: ["maj9"] },
  { name: "aug7", intervals: [0, 4, 8, 10], aliases: ["aug7"] },
  { name: "7b5", intervals: [0,4,6,10], aliases:["7b5"] },
  // ... you can add more patterns here if desired
];

function noteToPc(note) {
  // Normalize note like C, C#, Db, E, Fb etc.
  const s = note.trim();
  if (!s) return null;
  const up = s.replace("â™¯", "#").replace("â™­", "b");
  // Handle accidentals like E# -> F, B# -> C, Cb -> B
  const base = up[0].toUpperCase();
  let accidental = up.slice(1);
  // collapse double flats/sharps
  accidental = accidental.replace(/--/g, "").replace(/\+\+/g, "");

  const namesSharp = NOTE_NAMES_SHARP;
  const namesFlat = NOTE_NAMES_FLAT;
  // try direct sharp names
  const directSharp = namesSharp.indexOf(base + (accidental || ""));
  if (directSharp !== -1) return directSharp;
  const directFlat = namesFlat.indexOf(base + (accidental || ""));
  if (directFlat !== -1) return directFlat;

  // fallback: handle natural + accidental characters
  if (accidental === "#" || accidental === "â™¯") {
    const idx = namesSharp.indexOf(base);
    return (idx + 1) % 12;
  }
  if (accidental === "b" || accidental === "â™­") {
    const idx = namesSharp.indexOf(base);
    return (idx + 11) % 12;
  }
  // If single letter like E -> 4
  const idx = namesSharp.indexOf(base);
  if (idx !== -1) return idx;

  return null;
}

function pcsToNames(pcs, preferFlats = false) {
  const map = preferFlats ? NOTE_NAMES_FLAT : NOTE_NAMES_SHARP;
  return pcs.map((p) => map[((p % 12) + 12) % 12]);
}

function intervalsFromRoot(root, pcs) {
  // return sorted unique intervals (0 included)
  const ints = Array.from(
    new Set(
      pcs.map((p) => ((p - root) % 12 + 12) % 12)
    )
  ).sort((a, b) => a - b);
  return ints;
}

function matchPattern(intervals) {
  const matches = [];
  for (const pat of CHORD_PATTERNS) {
    // Compare by set inclusion: pattern intervals (mod 12) should be subset of given intervals (mod 12)
    const patSet = new Set(pat.intervals.map((i) => i % 12));
    const intSet = new Set(intervals.map((i) => i % 12));
    let ok = true;
    for (const p of patSet) {
      if (!intSet.has(p)) {
        ok = false;
        break;
      }
    }
    if (ok) {
      matches.push(pat);
    }
  }
  return matches;
}

function identifyChordsFromPcs(pcs) {
  // Try each pitch class as root candidate and produce matches.
  const uniquePcs = Array.from(new Set(pcs.map((p) => ((p % 12) + 12) % 12)));
  const results = [];
  for (const root of uniquePcs) {
    const ints = intervalsFromRoot(root, uniquePcs);
    const patterns = matchPattern(ints);
    for (const pat of patterns) {
      const name = `${NOTE_NAMES_SHARP[root]}${pat.aliases[0] || pat.name}`;
      // score: prefer patterns using more notes and simpler intervals
      const score = pat.intervals.length * 10 - ints.length;
      results.push({ root, pat, name, score, intervals: ints });
    }
  }
  // sort by score desc
  results.sort((a, b) => b.score - a.score);
  return results;
}

// Heuristic fret finder: for each string, find a fret (0-12) that matches any chord pitch class
// Try to keep max fret <= baseFret + span (span default 4)
function findFretboard(pcs, maxFret = 12, baseFretLimit = 5, span = 4) {
  // We'll attempt multiple base frets from 0..baseFretLimit and pick best
  const candidates = [];
  for (let base = 0; base <= baseFretLimit; base++) {
    // for each string, choose a fret between base and base+span (inclusive) that matches
    const fingering = [];
    let ok = true;
    for (let s = 0; s < 6; s++) {
      const openPc = GUITAR_STRINGS[s];
      let chosen = -1;
      // allow open string (fret 0) too by searching 0..base+span
      for (let f = 0; f <= Math.min(maxFret, base + span); f++) {
        const pc = (openPc + f) % 12;
        if (pcs.includes(pc)) {
          // prefer lower fret
          chosen = f;
          break;
        }
      }
      if (chosen === -1) {
        // maybe mark as muted 'x'
        fingering.push(null);
      } else {
        fingering.push(chosen);
      }
    }
    // score: number of matched strings - range span penalty
    const matched = fingering.filter((f) => f !== null).length;
    const maxF = Math.max(...fingering.map((f) => (f === null ? 0 : f)));
    const minF = Math.min(...fingering.map((f) => (f === null ? 99 : f)));
    const range = maxF - (minF === 99 ? 0 : minF);
    const score = matched * 10 - range;
    candidates.push({ base, fingering, score });
  }
  candidates.sort((a, b) => b.score - a.score);
  return candidates[0];
}

export default function GuitarChordExplorer() {
  const [useFlats, setUseFlats] = useState(false);
  const [keyChoice, setKeyChoice] = useState("C");
  const [input, setInput] = useState("C E G");
  const [transpose, setTranspose] = useState(0);

  const pcs = useMemo(() => {
    // parse input: accept notes separated by spaces, commas or slashes. also accept parentheses ignored.
    const cleaned = input.replace(/[()]/g, "").replace(/[,/]+/g, " ");
    const tokens = cleaned.split(/\s+/).filter(Boolean);
    const p = tokens
      .map((t) => noteToPc(t))
      .filter((x) => x !== null && x !== undefined)
      .map((n) => ((n + transpose) % 12 + 12) % 12);
    return p;
  }, [input, transpose]);

  const identifications = useMemo(() => identifyChordsFromPcs(pcs), [pcs]);
  const best = identifications[0] || null;
  const fretboard = useMemo(() => {
    if (!pcs || pcs.length === 0) return null;
    return findFretboard(pcs);
  }, [pcs]);

  return (
    <div className="p-6 max-w-4xl mx-auto font-sans">
      <h1 className="text-2xl font-bold mb-3">Guitar Chord Explorer ğŸ¸</h1>
      <p className="mb-4">è¼¸å…¥å’Œå¼¦çš„çµ„æˆéŸ³ï¼ˆä¾‹å¦‚ï¼šC E G æˆ– C,E,Gï¼‰ã€‚å¯é¸ Key ä»¥ä¾¿æ•´é¦–æ­Œè½‰èª¿ï¼ˆæœƒæ”¹è®Šé¡¯ç¤ºçš„å’Œå¼¦åç¨±èˆ‡æŒ‡æ³•ï¼‰ã€‚æ”¯æ´å¤§é‡å¸¸è¦‹èˆ‡é€²éšå’Œå¼¦é¡å‹ã€‚</p>

      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
        <div>
          <label className="block text-sm font-medium">Keyï¼ˆæ­Œæ›²èª¿æ€§ï¼Œå½±éŸ¿è½‰èª¿ï¼‰</label>
          <select className="mt-1 p-2 border rounded w-full" value={keyChoice} onChange={(e) => setKeyChoice(e.target.value)}>
            {MAJOR_KEYS.map((k) => (
              <option key={k} value={k}>{k}</option>
            ))}
          </select>
        </div>

        <div>
          <label className="block text-sm font-medium">Transpose (semitones)</label>
          <input type="range" min={-6} max={6} value={transpose} onChange={(e) => setTranspose(Number(e.target.value))} />
          <div className="text-sm">{transpose >= 0 ? `+${transpose}` : transpose} åŠéŸ³</div>
        </div>

        <div>
          <label className="block text-sm font-medium">é¡¯ç¤ºéŸ³ååå¥½</label>
          <div className="mt-1">
            <label className="inline-flex items-center mr-4">
              <input type="checkbox" className="mr-2" checked={useFlats} onChange={(e) => setUseFlats(e.target.checked)} /> ä½¿ç”¨é™è™Ÿï¼ˆBb, Ebï¼‰
            </label>
          </div>
        </div>
      </div>

      <div className="mb-4">
        <label className="block text-sm font-medium">å’Œå¼¦çµ„æˆéŸ³ï¼ˆå¯è¼¸å…¥ç©ºç™½æˆ–é€—è™Ÿåˆ†éš”ï¼‰</label>
        <input className="mt-1 p-2 border rounded w-full" value={input} onChange={(e) => setInput(e.target.value)} placeholder="ä¾‹å¦‚: C E G æˆ– G B D F#" />
      </div>

      <div className="mb-6">
        <h2 className="text-xl font-semibold">è¾¨è­˜çµæœ</h2>
        {pcs.length === 0 ? (
          <div className="text-gray-600">å°šæœªè¼¸å…¥æˆ–è§£æå‡ºä»»ä½•éŸ³ã€‚</div>
        ) : (
          <div className="mt-2">
            <div className="mb-2">è§£æå‡ºçš„éŸ³åï¼ˆpitch classesï¼‰ï¼š{pcsToNames(Array.from(new Set(pcs)), useFlats).join(', ')}</div>
            <div className="mb-2">å¯èƒ½çš„å’Œå¼¦ï¼š
              <ul className="list-disc pl-6 mt-1">
                {identifications.length === 0 && <li>æ‰¾ä¸åˆ°åŒ¹é…çš„å¸¸è¦‹å’Œå¼¦æ¨¡å¼</li>}
                {identifications.slice(0, 6).map((r, i) => (
                  <li key={i}>{NOTE_NAMES_SHARP[r.root]} {r.pat.name} â€” intervals: [{r.intervals.join(', ')}]</li>
                ))}
              </ul>
            </div>
            {best && (
              <div className="mt-3 p-3 border rounded bg-gray-50">
                <strong>æœ€ä½³åŒ¹é…ï¼š</strong> {best.name} (æ ¹éŸ³ {NOTE_NAMES_SHARP[best.root]})
              </div>
            )}
          </div>
        )}
      </div>

      <div>
        <h2 className="text-xl font-semibold mb-2">å‰ä»–æŒ‡æ³•ç¤ºæ„</h2>
        {fretboard ? (
          <div className="flex gap-6 items-start">
            <div className="p-3 border rounded">
              <div className="text-sm mb-2">å»ºè­°æŠŠä½ï¼ˆbase fret {fretboard.base})ï¼Œæ¯æ ¹å¼¦é¡¯ç¤ºè©²æŠŠä½ç›¸å°çš„å“æ ¼ï¼ˆnull=ä¸æŒ‰ = Xï¼‰</div>
              <table className="table-auto">
                <tbody>
                  {Array.from({ length: 6 }).map((_, idx) => {
                    const s = idx;
                    const f = fretboard.fingering[s];
                    const stringName = ["6(E)", "5(A)", "4(D)", "3(G)", "2(B)", "1(E)"][s];
                    return (
                      <tr key={s}>
                        <td className="pr-4 font-mono">{stringName}</td>
                        <td>{f === null ? 'X' : f}</td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
            </div>

            <div className="p-3 border rounded">
              <div className="text-sm mb-2">ç°¡æ˜“æŒ‡æ¿åœ–ï¼ˆ0 = open, X = mutedï¼‰</div>
              <div className="grid grid-cols-6 gap-2 text-center">
                {Array.from({ length: 6 }).map((_, s) => (
                  <div key={s} className="p-2 border rounded">
                    <div className="text-xs">{["E","A","D","G","B","E\`"].reverse()[s]}</div>
                    <div className="font-mono mt-1">{fretboard.fingering[5 - s] === null ? 'X' : fretboard.fingering[5 - s]}</div>
                  </div>
                ))}
              </div>
            </div>
          </div>
        ) : (
          <div className="text-gray-600">ç„¡æ³•ç”¢ç”ŸæŒ‡æ³•ï¼ˆè«‹ç¢ºèªå·²è¼¸å…¥æœ‰æ•ˆéŸ³ï¼‰</div>
        )}
      </div>

      <div className="mt-6 text-sm text-gray-600">
        <strong>èªªæ˜ï¼š</strong> æœ¬å·¥å…·ä»¥ã€Œå’Œå¼¦çµ„æˆéŸ³ã€ç‚ºè¼¸å…¥ï¼Œå˜—è©¦æ¯”å°å¤§é‡å¸¸è¦‹èˆ‡é€²éšå’Œå¼¦æ¨¡å¼ï¼ŒåŒ…æ‹¬å¤§ä¸‰ã€å°ä¸‰ã€å¢ã€æ¸›ã€ä¸ƒå’Œå¼¦ã€åŠæ¸›ã€å„ç¨® add / sus / omit ç­‰ã€‚è‹¥ä½ å¸Œæœ›ç›´æ¥è¼¸å…¥å’Œå¼¦æ–‡å­—ï¼ˆä¾‹å¦‚ Em7 / Cmaj7/Gï¼‰ï¼Œæœªä¾†å¯æ“´å……è§£æå™¨ä¾†æ¥å—é‚£äº›æ–‡å­—æ ¼å¼ä¸¦è‡ªå‹•æ‹†è§£ç‚ºçµ„æˆéŸ³ã€‚
      </div>

    </div>
  );
}
